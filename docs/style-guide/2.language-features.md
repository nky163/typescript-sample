# 言語機能

## ローカル変数の宣言

### 変更しない変数は `const`、再代入が必要な場合のみ `let`

- 意図（不変 or 可変）が一目で分かる
- 誤った再代入を防ぎ安全性向上
- TypeScript の型推論が安定

**❌ bad**

```typescript
let limit = 10; // 書き換えないのに let
limit = 10; // 冗長
```

**✅ good**

```typescript
const limit = 10; // 不変
let counter = 0; // 意図的に増加
counter++;
```

### `var` は使用しない

- 関数スコープ / hoisting により意図せぬ再定義バグ誘発
- `let` / `const` でブロックスコープを明示できる

**❌ bad**

```typescript
for (var i = 0; i < 3; i++) {}
console.log(i); // 3 が出力されスコープが広い
```

**✅ good**

```typescript
for (let i = 0; i < 3; i++) {}
// console.log(i); // 参照不可でリーク防止
```

## 配列リテラル

### 配列は `[]` リテラルで生成（`new Array()` を避ける）

- `new Array(n)` の引数意味が曖昧（長さ vs 要素）
- 推論された型が明確で読みやすい

**❌ bad**

```typescript
const nums = new Array(5); // 要素未定義の穴あき配列
```

**✅ good**

```typescript
const nums = [0, 0, 0, 0, 0];
```

### 変更不要な配列は `readonly` / `as const` を活用

- ミューテーションを防ぎ誤更新を検出
- リテラル形状からより狭い型を得られる

**❌ bad**

```typescript
const colors = ['red', 'green', 'blue'];
colors.push('yellow'); // 想定外の追加
```

**✅ good**

```typescript
const colors = ['red', 'green', 'blue'] as const; // Tuple 化で変更不能
type Color = (typeof colors)[number];
```

## オブジェクトリテラル

### オブジェクトリテラルの型安全化に `satisfies` を使う（過剰アサーション回避）

- 過剰な `as SomeType` を避けプロパティ typo を検出
- 実際の値型は保持され推論が失われない

**❌ bad**

```typescript
const cfg = { endpoint: '/api', timout: 5000 } as ApiConfig; // typo 見逃し
```

**✅ good**

```typescript
const cfg = { endpoint: '/api', timeout: 5000 } satisfies ApiConfig; // typo 防止
```

### 逐次的な空オブジェクト構築を避け一括初期化

- 中間の `any` 化や欠落プロパティを防ぐ
- 読みやすさ向上

**❌ bad**

```typescript
const user: User = {} as User;
user.id = 'u1';
user.name = 'Alice';
```

**✅ good**

```typescript
const user: User = { id: 'u1', name: 'Alice' };
```

## クラス

### 単なるデータ集約は interface / type + 関数で表現（DTO クラス乱造しない）

- 不要な `new` / `this` による複雑化回避
- テスト容易性（純粋データ）

**❌ bad**

```typescript
class UserInfo {
  constructor(
    public id: string,
    public name: string,
  ) {}
}
const u = new UserInfo('u1', 'Alice');
```

**✅ good**

```typescript
interface UserInfo {
  id: string;
  name: string;
}
const u: UserInfo = { id: 'u1', name: 'Alice' };
```

### 継承よりコンポジションを優先

- 多重継承的な密結合/破壊的変更リスク減少
- 小さい部品のテスト容易性

**❌ bad**

```typescript
class CachedSendMoneyService extends SendMoneyService {
  /* キャッシュ追加 */
}
```

**✅ good**

```typescript
class CachedSendMoneyService {
  constructor(
    private inner: SendMoneyService,
    private cache: Cache,
  ) {}
  execute(cmd: SendMoneyCommand) {
    // キャッシュ判定後 inner.execute(cmd)
  }
}
```

## 関数

### 公開/再利用ロジックは `function` 宣言、短いコールバックはアロー関数を使用する

方針:

- トップレベルの公開・再利用・再帰・テスト対象ロジック: **`function` 宣言**
- 短いコールバック / 高階関数引数 / インライン処理: **アロー関数**
- クラスの通常メソッド: 通常のメソッド記法 (`method() {}`)
- `this` をイベント等で固定したい場合のみ: クラスフィールドのアロー関数 (`handler = (...) => {}`)
- 公開 API に無名アロー関数代入 (`export const x = () => {}`) を乱用しない

説明:

- `function` 宣言はファイルの後ろに書いても前で呼び出せる & 例外/スタックトレースに名前が残り調査が容易
- アロー関数は短く書け外側の `this` をそのまま保持するのでコールバックで安全
- メソッド記法は prototype 共有でインスタンス毎の関数再生成を防ぎメモリ効率が良い
- アロー関数のクラスフィールドは `this` 固定が必要なケースに限定し乱用でのパフォーマンス低下を避ける
- 無名アロー関数の export は検索性・スタックトレースの可読性を損なう

**❌ bad**

```typescript
// 再利用関数を無名アローで export
export const calcTotal = (items: Item[]) => {
  return items.reduce((s, i) => s + i.price, 0);
};

// シンプルなコールバックを冗長な function 式
values.map(function (v) {
  return v.id;
});

// 不要にアローのインスタンスフィールド乱用
class Processor {
  process = (d: Data) => {
    /* ... */
  };
}
```

**✅ good**

```typescript
// 名前付きのトップレベル関数 (スタックトレース/再帰/検索に有利)
export function calcTotal(items: readonly Item[]): number {
  return items.reduce((s, i) => s + i.price, 0);
}

// コールバックは簡潔にアロー
values.map((v) => v.id);

// クラスメソッドは prototype で共有
class Processor {
  process(d: Data) {
    /* ... */
  }
}

// this を固定したいイベントハンドラのみアロー
class ButtonView {
  constructor(btn: HTMLButtonElement) {
    btn.addEventListener('click', this.handleClick); // バインド不要
  }
  private handleClick = (e: MouseEvent) => {
    this.log(e.type);
  };
  private log(msg: string) {
    /* ... */
  }
}
```

### 1 関数 1 責務（副作用と計算結果の混在を避ける）

- テスト対象の明確化
- 予測可能性と再利用性向上

**❌ bad**

```typescript
function calcAndLog(a: number, b: number) {
  const r = a + b;
  console.log(r); // 副作用
  return r * Math.random(); // 非決定性
}
```

**✅ good**

```typescript
function add(a: number, b: number) {
  return a + b;
}
function logResult(r: number) {
  console.log(r);
}
```

### 戻り値 `Promise<void>` に不要な never-resolve 処理を含めない

- 呼び出し側の完了判定が不能
- ハング検出困難

**❌ bad**

```typescript
async function run() {
  await new Promise(() => {}); // resolve されない
}
```

**✅ good**

```typescript
async function run() {
  await task();
}
```

## this

### クラスメソッド以外で `this` を暗黙利用しない（アロー関数で外側の this をそのまま使える性質を活かす）

- `this` バインドミスによる実行時エラー回避
- コールバックでの挙動が予測可能

**❌ bad**

```typescript
function register() {
  setTimeout(function () {
    this.send();
  }, 10); // this 不明
}
```

**✅ good**

```typescript
function register(send: () => void) {
  setTimeout(() => {
    send();
  }, 10);
}
```

## interface

### 実装のない共有契約は `interface`、ユニオン/マップ形状は `type`

- 拡張や宣言マージ前提は interface が自然
- 条件型等の型演算は type が柔軟

**❌ bad**

```typescript
type Service { execute(): void } // 構文エラーかつ意図不明
```

**✅ good**

```typescript
interface Service {
  execute(): void;
}
type ServiceResult = Success | Failure;
```

### ワイド型の後付けアサーションを避け最初に正しい形を定義

- `as any` / `as Foo` による安全性低下を防ぐ

**❌ bad**

```typescript
const data = fetchRaw() as any; // 以後 unsafe
const user = data as User;
```

**✅ good**

```typescript
interface User {
  id: string;
  name: string;
}
const user: User = fetchUser();
```

## プリミティブリテラル

### マジックナンバー / マジック文字列を定数化

- 意味付けにより変更影響箇所が明確
- タイポ検出容易

**❌ bad**

```typescript
if (status === 7) {
  /* ... */
}
```

**✅ good**

```typescript
const STATUS_RETRY_LIMIT_EXCEEDED = 7;
if (status === STATUS_RETRY_LIMIT_EXCEEDED) {
  /* ... */
}
```

### ユニオン型と `as const` を組み合わせ列挙表現

- `enum` 不要でツリーシェイク友好
- const enum 禁止方針とも整合

**❌ bad**

```typescript
enum Direction {
  Up = 'up',
  Down = 'down',
}
```

**✅ good**

```typescript
const directions = ['up', 'down'] as const;
type Direction = (typeof directions)[number];
```

## 制御構造(Control structures)

### ネストを浅く保ち早期 return でガード

- 読みやすさと差分効率向上
- 誤った else 分岐の混入を防ぐ

**❌ bad**

```typescript
function process(v?: string) {
  if (v) {
    if (v.length > 3) {
      run(v);
    }
  }
}
```

**✅ good**

```typescript
function process(v?: string) {
  if (!v) return;
  if (v.length <= 3) return;
  run(v);
}
```

### `switch` は全ケース網羅 + `default: never` アサーション

- 未処理ケース検出
- enum/ユニオン追加時の安全性

**❌ bad**

```typescript
switch (status) {
  case 'ok':
    handleOk();
    break;
  case 'error':
    handleErr();
    break;
} // 新ケース silent skip
```

**✅ good**

```typescript
switch (status) {
  case 'ok':
    handleOk();
    break;
  case 'error':
    handleErr();
    break;
  default:
    const _: never = status;
    throw new Error(status);
}
```

## デコレーター

### 実験的デコレーター利用は最小限・局所化

- TS の仕様変更リスク / emit 差異による破壊的変更を低減
- 代替（関数合成 / 高階関数）で十分か再評価

**❌ bad**

```typescript
@log
@cache
@metric
class Service {}
```

**✅ good**

```typescript
// 1 箇所に限定 / 仕組み化せず局所利用
@log
class Service {}
```

## 許可されていない機能

### `const enum` / `namespace` / `module` は使用しない

- バンドラ間の emit 差異・最適化阻害
- 既に ESM + ユニオン型で代替可能
- [const enum が禁止な理由](https://typescriptbook.jp/reference/values-types-variables/enum/enum-problems-and-alternatives-to-enums)

**❌ bad**

```typescript
const enum Role {
  Admin = 'admin',
}
namespace Legacy {
  export const x = 1;
}
```

**✅ good**

```typescript
const roles = ['admin'] as const;
type Role = (typeof roles)[number];
export const x = 1;
```

### グローバル汚染を伴う宣言マージの乱用禁止

- 衝突 / テスト順序依存バグを誘発

**❌ bad**

```typescript
declare global {
  interface Array<T> {
    last(): T | undefined;
  }
}
```

**✅ good**

```typescript
export function last<T>(arr: readonly T[]) {
  return arr[arr.length - 1];
}
```
