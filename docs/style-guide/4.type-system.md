# 型システム

本セクションは Google TypeScript Style Guide の Type System 節をベースに、本プロジェクトの既存ポリシー（`const enum` 禁止 / `as` 形式のアサーション節約 / `satisfies` 推奨 など）と重複しない形で要点を整理する。重複する原則は 2.language-features への参照を付す。

---

### 型推論を信頼し「明確な価値」がある時だけ注釈を書く

- 明白な初期化（`const n = 1;` や `new Set<string>()`）への冗長注釈はノイズ
- 複雑な式 / 返り値で意図が読み取りにくいケースは注釈で境界を固定し将来の破壊変更を早期検知
- 推論阻害（ジェネリックが `unknown` / `any` になる）を避けるため初期化側で型パラメータを与える

**❌ bad**

```typescript
const value: number = 42; // 自明
const users: Set<string> = new Set(); // 自明
```

**✅ good**

```typescript
const value = 42;
const users = new Set<string>(); // 空初期化で型パラメータ指定
const transformed: ReadonlyArray<UserDTO> = await service.fetch().then(mapper);
```

### `null` と `undefined` の扱い: 利用箇所で明示し両方まとめた曖昧別名を作らない

- まず「両方必要か」を検討。多くのケースでは「未設定」を `undefined` (欠如) だけで表せる
- `type MaybeUser = User | null | undefined` / `type Nullable<T> = T | null | undefined` のようなワイド別名は欠損条件を隠蔽するので禁止
- 欠損可能性は宣言箇所で直接 `User | undefined`、またはプロパティ/引数で optional (`avatarUrl?`) として表現
- 外部 API / DB が `null` を返すなど正当な理由がある場合のみ `| null` を付け、コメントで根拠を残す（`undefined` に正規化するラッパ実装も検討）
- optional 記号 `?` は `| undefined` のみを含み `null` は含まない点を明確に意識（両方必要なら `prop?: T | null` だが設計妥当性を再検討）

**❌ bad**

```typescript
type MaybeUser = User | null | undefined; // 欠損契機が不透明
type Nullable<T> = T | null | undefined; // ワイド別名テンプレート
interface Profile {
  avatarUrl?: string | null;
} // どちらか片方に寄せられる設計
```

**✅ good**

```typescript
function findUser(id: Id): User | undefined {
  /* 見つからない → undefined */
}
interface Profile {
  avatarUrl?: string;
} // 未設定は欠如/undefined
function fetchLegacy(): User | null {
  /* 外部レガシー API 契約: 無い時は null */
}
// 必要ならラップして内部では undefined に統一
async function getUser(id: Id): Promise<User | undefined> {
  const raw = await fetchLegacy();
  return raw === null ? undefined : raw;
}
```

### 構造的型: 期待する形を宣言に書き「後付けアサーション」を避ける

- 早期に `interface` / 型注釈を付けることで欠落/typo を定義位置で検出
- “ワイドに受けて狭くアサート” は安全性低下 & エラー地点が遠くなる
- 値リテラルには `satisfies` を活用（詳細: 言語機能 > オブジェクトリテラル）

**❌ bad**

```typescript
const raw = fetchJson() as any; // ワイド
const settings = raw as Settings; // 後付け
```

**✅ good**

```typescript
interface Settings {
  theme: 'light' | 'dark';
  locale: string;
}
const settings: Settings = await fetchSettings();
```

### オブジェクト形状には `interface`、型演算/ユニオンは `type` を使い分ける

- 拡張・宣言マージ・実装契約: `interface`
- ユニオン / 条件 / Mapped など型演算: `type`
- 一貫性が読みやすさ（既出: 言語機能 > interface 節）

**❌ bad**

```typescript
type User = { id: string; name: string };
interface IDOrName = string | number; // 構文/概念ミスマッチ
```

**✅ good**

```typescript
interface User {
  id: string;
  name: string;
}
type UserKey = keyof User;
type LoadResult = User | ErrorLike;
```

### 配列は単純型なら `T[]` / `readonly T[]`、複雑なら `Array<T>`

- シンプル: 可読性・短さを優先 (`User[]`, `readonly string[]`)
- ネスト複雑化 / ジェネリック結合時: `Array<Map<string,User>>` のように括りで誤読防止
- `readonly` は型レベル不変を明示（値ミューテーション防止）

**❌ bad**

```typescript
const list: Array<string> = ['a', 'b']; // 簡潔でよい場面
const matrix: string[][][] = [] as any; // 何階層か直感的でない
```

**✅ good**

```typescript
const list: string[] = ['a', 'b'];
const matrix: Array<string[][]> = build3D();
const readonlyIds: readonly string[] = ids;
```

### インデックスシグネチャより `Map / Record` を優先検討

- オブジェクトを辞書化すると prototype 混入・キー強制力欠如
- 既知キー集合は `Record<KeyUnion,Value>` で静的保証
- 任意文字列キーで値集約 → `Map<string,Value>` が明示的

**❌ bad**

```typescript
const counts: { [k: string]: number } = {};
counts[user.id] = 1;
```

**✅ good**

```typescript
const counts = new Map<string, number>();
const roleLabels: Record<'admin' | 'user', string> = { admin: '管理者', user: '利用者' };
```

### Mapped / Conditional Type は最小限（読みやすさ優先）

- 過剰な型演算は可読性/IDE サポート低下 & TS バージョン差異影響増
- 少しの重複は許容し明示型を優先
- 使用時は: (1) 入力型が安定 (2) 利得が複雑さに見合う かを確認

**❌ bad**

```typescript
type DeepPartial<T> = { [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K] }; // 汎用再帰を安易に導入
```

**✅ good**

```typescript
interface User {
  id: string;
  profile?: Profile;
}
// 必要範囲だけ手書き
interface PatchUser {
  profile?: Partial<Profile>;
}
```

### `any` は基本禁止・代替をまず検討

- `any` は型安全と補完を失わせバグ隠蔽
- 代替: (1) 具体的型 (2) ジェネリック (3) `unknown` + ナロー (4) ヘルパー型
- やむを得ず使用（テスト部分モック等）は lint 抑制コメント + 理由 を記述

**❌ bad**

```typescript
function parse(json: string): any {
  return JSON.parse(json);
}
const user: any = fetchUser();
user.mispell; // 検出不能
```

**✅ good**

```typescript
function parseUser(json: string): User {
  return JSON.parse(json) as User;
}
function load<T>(key: string): T {
  /* ... */
}
const data: unknown = JSON.parse(raw);
if (isUser(data)) {
  useUser(data);
}
```

### 不明値は `unknown` で受け取りガードで絞る

- `unknown` は参照操作を禁止しナロー必須にする安全デフォルト
- ランタイムチェック関数 (type guard) と組み合わせ意図的に安全性を復元

**❌ bad**

```typescript
function handle(data: any) {
  console.log(data.foo);
}
```

**✅ good**

```typescript
function handle(data: unknown) {
  if (isMessage(data)) {
    console.log(data.payload);
  }
}
```

### `{}` 型は避け意図を具体化 (`unknown` / `object` / `Record`)

- `{}` は “null/undefined を除く全て” で広すぎ & 誤解読
- 目的に応じ適切な代替を選択

**❌ bad**

```typescript
function logAny(o: {}): void {
  /* 何でも */
}
```

**✅ good**

```typescript
function logObject(o: object): void {}
function acceptRecord(r: Record<string, unknown>): void {}
let value: unknown;
```

### タプルは「意味のある固定長」に限定し名前が必要ならオブジェクトへ

- 位置依存は読み手コスト増 → 名前付プロパティが好ましい場合はオブジェクト
- 固定ペア / coordinate のような自然な並びはタプル適正

**❌ bad**

```typescript
type UserData = [string, number, string]; // 何が何か不明
```

**✅ good**

```typescript
type Coordinate = [number, number];
interface UserProfile {
  id: string;
  age: number;
  name: string;
}
```

### プリミティブ wrapper 型 (`String` / `Number` / `Boolean`) を使わない

- 意図せぬ真偽評価 / 余計なオブジェクト化でコスト増
- リテラル or プリミティブ型 (`string`, `number`, `boolean`) を使用

**❌ bad**

```typescript
const flag = new Boolean(false);
function toStr(v: String): String {
  return v;
}
```

**✅ good**

```typescript
const flag = false;
function toStr(v: string): string {
  return v;
}
```

### 返り値のみで決まるジェネリック（return type only generics）は避ける

- 呼び出し側が引数から型を決められず、暗黙の型依存で保守困難
- 型パラメータは入力・出力両方に現れる形で拘束する

**❌ bad**

```typescript
function makeEmpty<T>(): T {
  return {} as T;
} // 生成側が T を保証できない
```

**✅ good**

```typescript
function identity<T>(v: T): T {
  return v;
}
function fromJson<T>(json: string, reviver: (o: any) => T): T {
  /* ... */
}
```

### 型アサーションは最小限（`as` / 非 null `!` の使用理由を説明）

- アサーションは静的保証を無効化する “逃げ” の手段
- まず runtime チェック or 型設計改善 (`satisfies` / ガード) を試す
- やむを得ない場合コメントで根拠を示し、二段階アサーションは `unknown` 経由のみ許容する
- 言語機能 > アサーション節

**❌ bad**

```typescript
const user = load() as any as User; // 根拠なし二段階
const id = maybeId!; // 非 null 根拠不明
```

**✅ good**

```typescript
// backend が常に id を埋める契約 (2025-08 調査)
const id = response.id!;
// x is Foo because field 'kind' narrows it above
(x as Foo).run();
```

### 列挙は `const enum` 禁止 / ユニオン or 通常 enum で表現

- `const enum` はトランスパイル出力のインライン展開で取り違えと最適化差異リスク（既出: ESLint no-restricted-syntax）
- リテラルユニオン + `as const` 配列 / オブジェクトで軽量列挙、または runtime 値が必要なら `enum`

**❌ bad**

```typescript
const enum Color {
  Red = 'red',
  Blue = 'blue',
}
```

**✅ good**

```typescript
enum Color {
  Red = 'red',
  Blue = 'blue',
}
const DIRECTIONS = ['up', 'down', 'left', 'right'] as const;
type Direction = (typeof DIRECTIONS)[number];
```
